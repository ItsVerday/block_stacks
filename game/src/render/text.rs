use common::PlatformInterface;

#[macro_export]
macro_rules! text {
	($interface:tt, $x:tt, $y:tt, $color:tt; $($arg:tt)*) => {{
		render::text::draw_text($interface, &format!($($arg)*),  $x, $y, $color);
    }};
}

const GLYPH_COUNT: usize = 37;
static GLYPH_CHARS: [char; GLYPH_COUNT] = [
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
];
static GLYPH_PIXELS: [[u8; 5]; GLYPH_COUNT] = [
    [0b10111110, 0b10000101, 0b10000101, 0b10111110, 0b00000000], // A
    [0b10111111, 0b10100101, 0b10100101, 0b10011010, 0b00000000], // B
    [0b10011110, 0b10100001, 0b10100001, 0b10010010, 0b00000000], // C
    [0b10111111, 0b10100001, 0b10100001, 0b10011110, 0b00000000], // D
    [0b10111111, 0b10100101, 0b10100101, 0b10100001, 0b00000000], // E
    [0b10111111, 0b10000101, 0b10000101, 0b10000001, 0b00000000], // F
    [0b10011110, 0b10100001, 0b10100101, 0b10011101, 0b00000000], // G
    [0b10111111, 0b10000100, 0b10000100, 0b10111111, 0b00000000], // H
    [0b10100001, 0b10111111, 0b10100001, 0b00000000, 0b00000000], // I
    [0b10010000, 0b10100000, 0b10100000, 0b10011111, 0b00000000], // J
    [0b10111111, 0b10000100, 0b10001010, 0b10110001, 0b00000000], // K
    [0b10111111, 0b10100000, 0b10100000, 0b10100000, 0b00000000], // L
    [0b10111111, 0b10000010, 0b10000100, 0b10000010, 0b10111111], // M
    [0b10111111, 0b10000010, 0b10000100, 0b10111111, 0b00000000], // N
    [0b10011110, 0b10100001, 0b10100001, 0b10011110, 0b00000000], // O
    [0b10111111, 0b10000101, 0b10000101, 0b10000010, 0b00000000], // P
	[0b10011110, 0b10100001, 0b10010001, 0b10101110, 0b00000000], // Q
	[0b10111111, 0b10000101, 0b10000101, 0b10111010, 0b00000000], // R
	[0b10100010, 0b10100101, 0b10100101, 0b10011001, 0b00000000], // S
	[0b10000001, 0b10000001, 0b10111111, 0b10000001, 0b10000001], // T
	[0b10011111, 0b10100000, 0b10100000, 0b10011111, 0b00000000], // U
	[0b10001111, 0b10010000, 0b10100000, 0b10011111, 0b00000000], // V
	[0b10111111, 0b10010000, 0b10001000, 0b10010000, 0b10111111], // W
	[0b10111011, 0b10000100, 0b10000100, 0b10111011, 0b00000000], // X
	[0b10000011, 0b10000100, 0b10111000, 0b10000100, 0b10000011], // Y
	[0b10110001, 0b10101001, 0b10100101, 0b10100011, 0b00000000], // Z
	[0b10000000, 0b10000000, 0b10000000, 0b00000000, 0b00000000], // [Space]
	[0b10011110, 0b10101001, 0b10100101, 0b10011110, 0b00000000], // 0
	[0b10100010, 0b10111111, 0b10100000, 0b00000000, 0b00000000], // 1
	[0b10111001, 0b10100101, 0b10100101, 0b10100010, 0b00000000], // 2
	[0b10100001, 0b10100101, 0b10100101, 0b10011010, 0b00000000], // 3
	[0b10000111, 0b10000100, 0b10000100, 0b10111111, 0b00000000], // 4
	[0b10100111, 0b10100101, 0b10100101, 0b10011001, 0b00000000], // 5
	[0b10011110, 0b10100101, 0b10100101, 0b10011000, 0b00000000], // 6
	[0b10000001, 0b10111001, 0b10000101, 0b10000011, 0b00000000], // 7
	[0b10011010, 0b10100101, 0b10100101, 0b10011010, 0b00000000], // 8
	[0b10000110, 0b10101001, 0b10101001, 0b10011110, 0b00000000]  // 9
];

pub fn find_char(c: char) -> Option<usize> {
    for index in 0..GLYPH_CHARS.len() {
        if c == GLYPH_CHARS[index] {
            return Some(index);
        }
    }

    None
}

pub fn draw_text(interface: &mut PlatformInterface, string: &str, x: f64, y: f64, color: u8) {
    let mut current_x = x;
    let current_y = y;

    for c in string.chars() {
        if let Some(index) = find_char(c) {
            let pixels = GLYPH_PIXELS[index];
            for column in pixels {
                if column & 0b10000000 == 0 {
                    break;
                }

                let mut mask = 0b1;
                for b in 0..7 {
                    if column & mask != 0 {
                        interface.set_pixel(current_x, current_y + b as f64, color);
                    }
                    
                    mask <<= 1;
                }

                current_x += 1.0;
            }

			current_x += 1.0;
        }
    }
}